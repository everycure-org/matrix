name: Release
on:
  pull_request:
    types: [closed]

jobs:
  approved:
    if: |
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'Release')
    runs-on: ubuntu-latest
    name: PR approval
    permissions:
      pull-requests: 'read'

    steps:
      - name: "Check the PR state"
        run: echo "The release PR is approved and merged"

  create_release:
    needs: [approved]
    runs-on: ubuntu-latest
    name: Create release
    permissions:
      contents: 'write'

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-tags: true
          fetch-depth: 0

      - name: Discover the intended release
        id: fetch_release_version
        env:
          PR_BRANCH_NAME: ${{ github.event.pull_request.head.ref }}
        run: |
          set -euxo pipefail
          # Note: this could be an intermediate release
          intended_release=${PR_BRANCH_NAME##release/}
          echo "intended_tag=${intended_release}" >> "$GITHUB_ENV"  

      - name: Discover Latest Official Release on GitHub
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          latest_official_release=$(gh release list --jq '.[0].tagName' --json tagName --order desc)
          echo "latest_official_release=${latest_official_release}" >> "$GITHUB_ENV"  

      - name: Create GitHub release
        env:
            GH_TOKEN: ${{ github.token }}
            POSTS_DIR: docs/src/releases/posts
        run: |
          set -euxo pipefail
          echo "Creating release"
          # If intended release comes after latest_official_release, flag it with --latest. Otherwise, don't.
          highest_version=$(echo -e "${{env.intended_tag}}\n${{env.latest_official_release}}" | sort --version-sort | tail -n1)
          if [ "${{ env.intended_tag }}" = "${highest_version}" ]; then ARG_LATEST=(--latest); else ARG_LATEST=( ); fi
          
          # If the notes file is generated, pass it to --notes-file. Otherwise, pass a default note.
          NOTES_FILE="${GITHUB_WORKSPACE}/${POSTS_DIR}/${{ env.intended_tag }}/notes.md"
          
          if [ -f "$NOTES_FILE" ]; then 
            # Remove the mkdocs frontmatter 
            sed -i '1,/^---/d' "${NOTES_FILE}" 
            ARG_NOTES=(--notes-file "${NOTES_FILE}") 
          else ARG_NOTES=(--notes 'This is a patch bump.')
          fi

          gh release create "${{ env.intended_tag }}" \
            --title "${{ env.intended_tag }}" \
            "${ARG_NOTES[@]}" \
            "${ARG_LATEST[@]}"
