_spark_parquet_ds: &_spark_parquet
  type: matrix.datasets.gcp.LazySparkDataset
  file_format: parquet
  save_args:
    mode: overwrite

_pandas_csv: &_pandas_csv
  type:  pandas.CSVDataset

# NOTE: Comes from embeddings dataset
_neo4j_ds: &_neo4j_ds
  type: matrix.datasets.neo4j.Neo4JSparkDataset
  database: moa
  url: ${globals:neo4j.host}
  credentials: neo4j_credentials
  save_args:
    mode: "overwrite"
  metadata:
    kedro-viz:
      layer: embeddings

# drugmech.raw.moa:
#   type: yaml.YAMLDataset
#   filepath: ${globals:paths.raw}/moa_extraction/indication_paths.yaml

# drugmech.int.moa@pandas:
#   <<: *_pandas_csv
#   filepath: ${globals:paths.int}/moa_extraction/paths.csv

# drugmech.int.moa@spark:
#   type: matrix.datasets.gcp.LazySparkDataset
#   filepath: ${globals:paths.int}/moa_extraction/paths.csv
#   file_format: csv

raw.drug_disease_inputs:
  type: matrix.datasets.gcp.LazySparkDataset
  file_format: csv
  filepath: gs://mtrx-us-central1-hub-dev-storage/data/01_RAW/moa_extraction/filtered_matrix_report_xg_ensemble_report_17_sept_2024.csv
  load_args:
    header: True

tps:
  type: matrix.datasets.gcp.LazySparkDataset
  filepath: ${globals:paths.raw}/ground_truth_data/tp_pairs.txt
  file_format: csv
  load_args:
    sep: "\t"
    header: True

int.tps:
  <<: *_spark_parquet
  filepath: int/tmps

int.drug.index:
  <<: *_neo4j_ds
  save_args:
    script: >
      CREATE CONSTRAINT IF NOT EXISTS FOR (n:is_drug) REQUIRE n.id IS UNIQUE;
    query: >
      MATCH (n:Entity {id: event.id})
      WITH n
      CALL apoc.create.addLabels(n, ['is_drug']) YIELD node
      RETURN node 

int.disease.index:
  <<: *_neo4j_ds
  save_args:
    script: >
      CREATE CONSTRAINT IF NOT EXISTS FOR (n:is_disease) REQUIRE n.id IS UNIQUE;
    query: >
      MATCH (n:Entity {id: event.id})
      WITH n
      CALL apoc.create.addLabels(n, ['is_disease']) YIELD node
      RETURN node 

int.edges_index:
  <<: *_neo4j_ds
  save_args:
    query: >
      MATCH (subject:Entity {id: event.drug_id}), (object:Entity {id: event.disease_id})
      WITH subject, object, event
      CALL apoc.create.relationship(subject, "is_treats", {}, object) YIELD rel
      RETURN rel

# int.all_paths:
#   <<: *_neo4j_ds
#   load_args: 
#     # NOTE: This is not indexed yet!
#     # query: MATCH (drug_id:Drug)-[edge]->(disease_id:Disease) return drug_id, type(edge), disease_id
#     relationship.source.labels: :Drug
#     relationship.target.labels: :Disease
  # save_args:
  #   mode: overwrite
  #   script: >
  #     CREATE CONSTRAINT IF NOT EXISTS FOR (n:Entity) REQUIRE n.id IS UNIQUE;
  #   query: > 
  #     CREATE (n:Entity {id: event.id, kg_sources: event.kg_sources})
  #     WITH event, n
  #     CALL apoc.create.addLabels(n, [event.label]) YIELD node
  #     CALL apoc.create.setProperties(n, event.property_keys, event.property_values) YIELD node AS n2
  #     RETURN node