# Neo4J graph database configuration. Used to orchestrate
# queries into Neo4j.
embeddings.gdb:
  object: matrix.pipelines.embeddings.nodes.GraphDB
  endpoint: ${oc.env:NEO4J_HOST}
  database: everycure-${globals:versions.release}
  auth:
    -  ${oc.env:NEO4J_USER}
    -  ${oc.env:NEO4J_PASSWORD}

# Establishes connection to localized mock GenAI API for
# testing purposes.
# https://neo4j.com/labs/apoc/5/ml/openai/
embeddings.ai_config:
  api_key: ${oc.env:OPENAI_API_KEY} 
  attribute: &_property embedding
  batch_size: 1 # NOTE: The MockApi does not support batching, hence disabled
  endpoint: ${oc.env:OPENAI_ENDPOINT}
  model: text-embedding-3-small
  concurrency: 50

# Attributes used as input features to compute
# node embeddings.
embeddings.node.features: ["category", "name"]

# Defines strategy used to reduce dimensions of the GenAI
# generated node embeddings.
# https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.feature.PCA.html
embeddings.dimensionality_reduction:
  input: *_property
  output: &_pca_property 'pca_embedding'
  transformer:
    object: pyspark.ml.feature.PCA
    k: 2

# FUTURE: This is a highly temp. solution that serves as PoC of leveraging Neo4J's
# AI functionality. If works as expected, we'll do a refinement step to clean this up.
embeddings.gds:
  object: matrix.pipelines.embeddings.nodes.GraphDS
  endpoint: ${oc.env:NEO4J_HOST}
  database: everycure-${globals:versions.release}
  auth:
    -  ${oc.env:NEO4J_USER}
    -  ${oc.env:NEO4J_PASSWORD}

# Defines strategy used to compute topological embeddings,
# all nodes and relationships in our KG are projected, along with
# the PCA feature. The graphSage algorithm is hereafter applied
# and the result is written back to the KG.
# 
# Sources:
#   - https://neo4j.com/docs/graph-data-science/current/management-ops/graph-creation/graph-project/
#   - https://neo4j.com/docs/graph-data-science-client/current/graph-object/
#   - https://neo4j.com/docs/graph-data-science-client/current/model-object/
#   - https://neo4j.com/docs/graph-data-science-client/current/algorithms/ 
# 
embeddings.topological:
  projection:
    graphName: embeddings
    nodeProjection:
      Entity:
        label: 'Entity'
        properties: *_pca_property
    relationshipProjection: '*'
    configuration:
      relationshipProperties: [&_weight_attribute include_in_graphsage]
  estimator:
    model: graphSage
    args:
      modelName: topological_embeddings
      featureProperties: [*_pca_property]
      concurrency: 4
      # FUTURE: We're currently leveraging a binary weighting strategy to exclude  
      # certain relationships. Another option could be to leverage filtering:
      # https://neo4j.com/docs/graph-data-science/current/management-ops/graph-creation/graph-filter/
      relationshipWeightProperty: *_weight_attribute
      # Chunyu: 512
      embeddingDimension: 3
      # Chunyu: 200k
      batchSize: 20
      epochs: 10
      searchDepth: 100
      # Chunyu
      # learningRate: 0.01
      learningRate: 0.1
  write_property: topological_embedding